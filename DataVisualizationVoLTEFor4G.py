import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import numpy as np
import os
import warnings
from datetime import datetime, timedelta
from PIL import Image, ImageDraw, ImageFont
import math

# T·∫Øt warnings ƒë·ªÉ output s·∫°ch h∆°n
warnings.filterwarnings('ignore')


class VoLTEKPIProcessor:
    def __init__(self):
        """
        Kh·ªüi t·∫°o class processor v·ªõi c·∫•u h√¨nh matplotlib ti·∫øng Vi·ªát
        """
        # C·∫•u h√¨nh matplotlib ƒë·ªÉ hi·ªÉn th·ªã ti·∫øng Vi·ªát
        plt.rcParams['font.family'] = 'DejaVu Sans'
        plt.rcParams['axes.unicode_minus'] = False

        self.cleaned_data = {}
        self.csv_files = {}

        print("VOLTE KPI DATA PROCESSOR")
        print("=" * 70)

    def read_excel_file(self, excel_path):
        """
        ƒê·ªçc file Excel v√† x√°c ƒë·ªãnh c√°c sheets c·∫ßn x·ª≠ l√Ω
        """
        try:
            print(f"üìñ ƒêang ƒë·ªçc file Excel: {excel_path}")

            # ƒê·ªçc t·∫•t c·∫£ sheet names
            excel_file = pd.ExcelFile(excel_path)
            all_sheets = excel_file.sheet_names
            print(f"üìä T·∫•t c·∫£ sheets: {all_sheets}")

            # X√°c ƒë·ªãnh c√°c sheet d·ªØ li·ªáu c·∫ßn x·ª≠ l√Ω (ch·ªâ 2 sheet ƒë·∫ßu ti√™n)
            target_sheets = ["Net KPI_Daily", "Net KPI_Hourly"]

            # T√¨m sheets c√≥ s·∫µn
            available_sheets = []
            for sheet in target_sheets:
                if sheet in all_sheets:
                    available_sheets.append(sheet)
                    print(f"‚úÖ T√¨m th·∫•y sheet: {sheet}")
                else:
                    # T√¨m sheet t∆∞∆°ng t·ª±
                    similar_sheet = self._find_similar_sheet(sheet, all_sheets)
                    if similar_sheet:
                        available_sheets.append(similar_sheet)
                        print(f"‚úÖ T√¨m th·∫•y sheet t∆∞∆°ng t·ª±: {similar_sheet}")
                    else:
                        print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y sheet: {sheet}")

            if not available_sheets:
                print("‚ùå Kh√¥ng t√¨m th·∫•y sheet d·ªØ li·ªáu c·∫ßn thi·∫øt!")
                return None

            # ƒê·ªçc d·ªØ li·ªáu t·ª´ c√°c sheets
            dataframes = {}
            for sheet_name in available_sheets:
                print(f"üìñ ƒêang ƒë·ªçc sheet: {sheet_name}")

                # ƒê·ªçc v·ªõi nhi·ªÅu ph∆∞∆°ng ph√°p ƒë·ªÉ tr√°nh l·ªói
                df = self._read_sheet_robust(excel_file, sheet_name)

                if df is not None and not df.empty:
                    dataframes[sheet_name] = df
                    print(f"   üìä K√≠ch th∆∞·ªõc raw: {df.shape}")
                else:
                    print(f"   ‚ùå Kh√¥ng th·ªÉ ƒë·ªçc d·ªØ li·ªáu t·ª´ {sheet_name}")

            return dataframes

        except Exception as e:
            print(f"‚ùå L·ªói khi ƒë·ªçc file Excel: {e}")
            return None

    def _find_similar_sheet(self, target_sheet, all_sheets):
        """
        T√¨m sheet c√≥ t√™n t∆∞∆°ng t·ª±
        """
        target_lower = target_sheet.lower()
        for sheet in all_sheets:
            sheet_lower = sheet.lower()
            if any(keyword in sheet_lower for keyword in ['daily', 'hourly', 'kpi']):
                if 'daily' in target_lower and 'daily' in sheet_lower:
                    return sheet
                elif 'hourly' in target_lower and ('hourly' in sheet_lower or 'hour' in sheet_lower):
                    return sheet
        return None

    def _read_sheet_robust(self, excel_file, sheet_name):
        """
        ƒê·ªçc sheet v·ªõi nhi·ªÅu ph∆∞∆°ng ph√°p ƒë·ªÉ ƒë·∫£m b·∫£o th√†nh c√¥ng
        """
        try:
            # Th·ª≠ ƒë·ªçc v·ªõi header m·∫∑c ƒë·ªãnh
            df = pd.read_excel(excel_file, sheet_name=sheet_name, header=0)

            # Ki·ªÉm tra xem c√≥ ph·∫£i header th·ª±c s·ª± kh√¥ng
            if self._is_valid_header(df):
                return df

            # N·∫øu kh√¥ng, th·ª≠ t√¨m header th·ª±c s·ª±
            for header_row in range(0, min(10, len(df))):
                try:
                    df_test = pd.read_excel(excel_file, sheet_name=sheet_name, header=header_row)
                    if self._is_valid_header(df_test):
                        print(f"   üéØ T√¨m th·∫•y header th·ª±c t·∫ø ·ªü d√≤ng {header_row}")
                        return df_test
                except:
                    continue

            # N·∫øu v·∫´n kh√¥ng t√¨m ƒë∆∞·ª£c, s·ª≠ d·ª•ng ph∆∞∆°ng ph√°p cu·ªëi c√πng
            df = pd.read_excel(excel_file, sheet_name=sheet_name, header=None)
            return df

        except Exception as e:
            print(f"   ‚ùå L·ªói khi ƒë·ªçc sheet {sheet_name}: {e}")
            return None

    def _is_valid_header(self, df):
        """
        Ki·ªÉm tra xem header c√≥ h·ª£p l·ªá kh√¥ng
        """
        if df.empty or len(df.columns) < 2:
            return False

        # T√¨m c√°c t·ª´ kh√≥a quan tr·ªçng trong header
        header_keywords = ['Date', 'Time', 'VoLTE', 'CSSR', 'CDR', 'Traffic',
                           'SRVCC', 'SR', 'HOSR', 'GB', '%', 'Rate']

        header_str = ' '.join([str(col) for col in df.columns])

        # Ki·ªÉm tra c√≥ √≠t nh·∫•t 2 t·ª´ kh√≥a
        keyword_count = sum(1 for keyword in header_keywords if keyword in header_str)

        return keyword_count >= 2

    def clean_dataframe_enhanced(self, df, sheet_name):
        """
        L√†m s·∫°ch dataframe v·ªõi x·ª≠ l√Ω n√¢ng cao v√† chi ti·∫øt h∆°n
        """
        print(f"üßπ L√†m s·∫°ch d·ªØ li·ªáu n√¢ng cao cho {sheet_name}...")
        print(f"   üìä Tr∆∞·ªõc khi l√†m s·∫°ch: {df.shape}")

        if df.empty:
            print("   ‚ùå DataFrame r·ªóng!")
            return None

        # 1. X·ª≠ l√Ω t√™n c·ªôt
        df = self._clean_column_names(df)

        # 2. T√¨m v√† thi·∫øt l·∫≠p header ƒë√∫ng
        df = self._fix_header_row(df, sheet_name)

        if df is None or df.empty:
            return None

        # 3. X√≥a c√°c c·ªôt v√† h√†ng kh√¥ng c·∫ßn thi·∫øt
        df = self._remove_unnecessary_data(df)

        # 4. X·ª≠ l√Ω c·ªôt Date/Time
        df = self._process_datetime_column(df)

        # 5. Chuy·ªÉn ƒë·ªïi c√°c c·ªôt s·ªë
        df = self._convert_numeric_columns(df)

        # 6. L√†m s·∫°ch d·ªØ li·ªáu cu·ªëi c√πng
        df = self._final_cleanup(df)

        if df is None or df.empty:
            print(f"   ‚ùå Kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá sau khi l√†m s·∫°ch!")
            return None

        print(f"   ‚ú® Sau khi l√†m s·∫°ch: {df.shape}")
        print(f"   üìã C√°c c·ªôt cu·ªëi c√πng: {list(df.columns[:10])}")

        return df

    def _clean_column_names(self, df):
        """
        L√†m s·∫°ch t√™n c·ªôt
        """
        df.columns = df.columns.astype(str)
        df.columns = [col.strip().replace('\n', ' ').replace('\r', ' ').replace('  ', ' ')
                      for col in df.columns]
        return df

    def _fix_header_row(self, df, sheet_name):
        """
        T√¨m v√† s·ª≠a d√≤ng header ƒë√∫ng
        """
        # T√¨m d√≤ng ch·ª©a t·ª´ kh√≥a quan tr·ªçng
        header_keywords = ['Date', 'Time', 'VoLTE', 'CSSR', 'CDR', 'Traffic', 'SRVCC']

        for i in range(min(5, len(df))):
            row_str = ' '.join([str(val) for val in df.iloc[i].values if pd.notna(val)])
            keyword_count = sum(1 for keyword in header_keywords if keyword in row_str)

            if keyword_count >= 2:  # √çt nh·∫•t 2 t·ª´ kh√≥a
                print(f"   üéØ T√¨m th·∫•y header th·ª±c t·∫ø ·ªü d√≤ng {i}")

                # T·∫°o header m·ªõi
                new_header = []
                for val in df.iloc[i].values:
                    if pd.notna(val) and str(val).strip() != '':
                        new_header.append(str(val).strip())
                    else:
                        new_header.append(f'Col_{len(new_header)}')

                # T·∫°o DataFrame m·ªõi
                data_rows = df.iloc[i + 1:].values
                if len(data_rows) == 0:
                    return None

                # ƒê·∫£m b·∫£o s·ªë c·ªôt kh·ªõp
                min_cols = min(len(new_header), data_rows.shape[1] if len(data_rows) > 0 else 0)
                if min_cols == 0:
                    return None

                new_header = new_header[:min_cols]
                data_rows = data_rows[:, :min_cols]

                df_new = pd.DataFrame(data_rows, columns=new_header)
                return df_new

        return df  # Tr·∫£ v·ªÅ DataFrame g·ªëc n·∫øu kh√¥ng t√¨m th·∫•y header t·ªët h∆°n

    def _remove_unnecessary_data(self, df):
        """
        X√≥a c√°c c·ªôt v√† h√†ng kh√¥ng c·∫ßn thi·∫øt
        """
        # X√≥a c√°c c·ªôt Unnamed
        unnamed_cols = [col for col in df.columns if 'Unnamed' in str(col) or 'Col_' in str(col)]
        if unnamed_cols:
            df = df.drop(columns=unnamed_cols, errors='ignore')
            print(f"   üóëÔ∏è ƒê√£ x√≥a {len(unnamed_cols)} c·ªôt kh√¥ng t√™n")

        # X√≥a c√°c c·ªôt ho√†n to√†n tr·ªëng
        df = df.dropna(axis=1, how='all')

        # X√≥a c√°c h√†ng ho√†n to√†n tr·ªëng
        df = df.dropna(axis=0, how='all')

        # X√≥a c√°c h√†ng c√≥ qu√° √≠t d·ªØ li·ªáu
        threshold = max(2, len(df.columns) * 0.3)  # √çt nh·∫•t 30% c·ªôt c√≥ d·ªØ li·ªáu
        df = df.dropna(thresh=threshold)

        return df.reset_index(drop=True)

    def _process_datetime_column(self, df):
        """
        X·ª≠ l√Ω c·ªôt Date/Time
        """
        if len(df.columns) == 0 or len(df) == 0:
            return df

        # T√¨m c·ªôt Date
        date_col = None
        for col in df.columns[:3]:  # Ki·ªÉm tra 3 c·ªôt ƒë·∫ßu
            col_str = str(col).lower()
            if any(keyword in col_str for keyword in ['date', 'time', 'ng√†y', 'gi·ªù']):
                date_col = col
                break

        if date_col is None:
            date_col = df.columns[0]  # M·∫∑c ƒë·ªãnh c·ªôt ƒë·∫ßu ti√™n

        print(f"   üìÖ X·ª≠ l√Ω c·ªôt th·ªùi gian: {date_col}")

        try:
            # Th·ª≠ c√°c ph∆∞∆°ng ph√°p chuy·ªÉn ƒë·ªïi kh√°c nhau
            original_data = df[date_col].copy()

            # Ph∆∞∆°ng ph√°p 1: Chuy·ªÉn ƒë·ªïi tr·ª±c ti·∫øp
            df[date_col] = pd.to_datetime(df[date_col], errors='coerce')

            # N·∫øu c√≥ qu√° nhi·ªÅu NaT, th·ª≠ ph∆∞∆°ng ph√°p kh√°c
            nat_count = df[date_col].isna().sum()
            if nat_count > len(df) * 0.5:  # H∆°n 50% l√† NaT
                print(f"   ‚ö†Ô∏è Qu√° nhi·ªÅu ng√†y kh√¥ng h·ª£p l·ªá, th·ª≠ ph∆∞∆°ng ph√°p kh√°c...")

                # Ph∆∞∆°ng ph√°p 2: X·ª≠ l√Ω s·ªë Excel
                try:
                    df[date_col] = pd.to_datetime(original_data, origin='1899-12-30', unit='D', errors='coerce')
                    nat_count = df[date_col].isna().sum()
                except:
                    pass

                # Ph∆∞∆°ng ph√°p 3: Parsing linh ho·∫°t
                if nat_count > len(df) * 0.5:
                    try:
                        df[date_col] = pd.to_datetime(original_data, infer_datetime_format=True, errors='coerce')
                    except:
                        pass

            # Lo·∫°i b·ªè c√°c h√†ng c√≥ ng√†y kh√¥ng h·ª£p l·ªá
            valid_dates = df[date_col].notna()
            df = df[valid_dates].reset_index(drop=True)

            # S·∫Øp x·∫øp theo ng√†y
            if len(df) > 0:
                df = df.sort_values(by=date_col).reset_index(drop=True)
                print(f"   ‚úÖ ƒê√£ chuy·ªÉn ƒë·ªïi {len(df)} ng√†y h·ª£p l·ªá")

        except Exception as e:
            print(f"   ‚ö†Ô∏è L·ªói x·ª≠ l√Ω ng√†y th√°ng: {e}")

        return df

    def _convert_numeric_columns(self, df):
        """
        Chuy·ªÉn ƒë·ªïi c√°c c·ªôt s·ªë
        """
        numeric_converted = 0

        # B·ªè qua c·ªôt ƒë·∫ßu ti√™n (Date/Time)
        for col in df.columns[1:]:
            try:
                original_count = df[col].count()

                # X·ª≠ l√Ω c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát trong s·ªë
                if df[col].dtype == 'object':
                    df[col] = df[col].astype(str).str.replace(',', '').str.replace('%', '').str.replace(' ', '')
                    df[col] = df[col].replace(['', 'nan', 'NaN', 'null', 'NULL', '-'], np.nan)

                # Chuy·ªÉn ƒë·ªïi sang s·ªë
                df[col] = pd.to_numeric(df[col], errors='coerce')

                new_count = df[col].count()

                if new_count > 0:
                    numeric_converted += 1
                    if new_count < original_count:
                        lost_pct = (original_count - new_count) / original_count * 100
                        if lost_pct > 20:  # C·∫£nh b√°o n·∫øu m·∫•t qu√° 20% d·ªØ li·ªáu
                            print(f"   ‚ö†Ô∏è {col}: m·∫•t {lost_pct:.1f}% d·ªØ li·ªáu ({original_count} -> {new_count})")

            except Exception as e:
                print(f"   ‚ö†Ô∏è L·ªói chuy·ªÉn ƒë·ªïi c·ªôt {col}: {e}")
                continue

        print(f"   üî¢ ƒê√£ chuy·ªÉn ƒë·ªïi {numeric_converted} c·ªôt sang ki·ªÉu s·ªë")
        return df

    def _final_cleanup(self, df):
        """
        L√†m s·∫°ch cu·ªëi c√πng
        """
        # X√≥a c√°c h√†ng c√≥ qu√° √≠t d·ªØ li·ªáu
        min_valid_cols = max(2, len(df.columns) * 0.4)  # √çt nh·∫•t 40% c·ªôt c√≥ d·ªØ li·ªáu
        df = df.dropna(thresh=min_valid_cols)

        # X√≥a c√°c c·ªôt c√≥ qu√° √≠t d·ªØ li·ªáu
        min_valid_rows = max(1, len(df) * 0.1)  # √çt nh·∫•t 10% h√†ng c√≥ d·ªØ li·ªáu
        df = df.dropna(axis=1, thresh=min_valid_rows)

        return df.reset_index(drop=True)

    def save_to_csv(self, dataframes, output_dir="output_charts"):
        """
        L∆∞u c√°c DataFrame th√†nh file CSV
        """
        print(f"\nüíæ L∆∞u d·ªØ li·ªáu th√†nh CSV...")
        os.makedirs(output_dir, exist_ok=True)

        for sheet_name, df in dataframes.items():
            # T·∫°o t√™n file CSV
            if 'Daily' in sheet_name or 'daily' in sheet_name.lower():
                csv_filename = 'Net_KPI_Daily.csv'
            elif 'Hourly' in sheet_name or 'hourly' in sheet_name.lower() or 'hour' in sheet_name.lower():
                csv_filename = 'Net_KPI_Hourly.csv'
            else:
                safe_name = "".join(c for c in sheet_name if c.isalnum() or c in (' ', '-', '_')).replace(' ', '_')
                csv_filename = f'{safe_name}.csv'

            csv_path = os.path.join(output_dir, csv_filename)

            try:
                df.to_csv(csv_path, index=False, encoding='utf-8-sig')
                print(f"‚úÖ ƒê√£ l∆∞u: {csv_filename} ({df.shape[0]} h√†ng √ó {df.shape[1]} c·ªôt)")

                # L∆∞u th√¥ng tin ƒë·ªÉ t·∫°o bi·ªÉu ƒë·ªì sau
                self.csv_files[sheet_name] = csv_path
                self.cleaned_data[sheet_name] = df

            except Exception as e:
                print(f"‚ùå L·ªói khi l∆∞u {csv_filename}: {e}")

        return self.csv_files

    def create_charts_from_csv(self, output_dir="output_charts"):
        """
        T·∫°o bi·ªÉu ƒë·ªì t·ª´ c√°c file CSV
        """
        print(f"\nüé® T·∫°o bi·ªÉu ƒë·ªì t·ª´ d·ªØ li·ªáu CSV...")

        for sheet_name, csv_path in self.csv_files.items():
            # X√°c ƒë·ªãnh lo·∫°i bi·ªÉu ƒë·ªì
            if 'Daily' in sheet_name or 'daily' in sheet_name.lower():
                chart_folder = os.path.join(output_dir, "Chart_daily")
                data_type = "Daily"
            elif 'Hourly' in sheet_name or 'hourly' in sheet_name.lower():
                chart_folder = os.path.join(output_dir, "Chart_hourly")
                data_type = "Hourly"
            else:
                chart_folder = os.path.join(output_dir, "Charts")
                data_type = "General"

            # T·∫°o bi·ªÉu ƒë·ªì
            self._generate_charts_for_data(csv_path, chart_folder, data_type)

    def _generate_charts_for_data(self, csv_file, chart_folder, data_type):
        """
        T·∫°o bi·ªÉu ƒë·ªì cho m·ªôt file CSV c·ª• th·ªÉ
        """
        print(f"\nüìä T·∫°o bi·ªÉu ƒë·ªì {data_type}...")

        if not os.path.exists(csv_file):
            print(f"   ‚ùå Kh√¥ng t√¨m th·∫•y file: {csv_file}")
            return

        os.makedirs(chart_folder, exist_ok=True)

        try:
            # ƒê·ªçc d·ªØ li·ªáu
            df = pd.read_csv(csv_file)
            print(f"   üìä ƒê·ªçc d·ªØ li·ªáu: {df.shape}")

            if df.empty or len(df.columns) < 2:
                print(f"   ‚ö†Ô∏è D·ªØ li·ªáu kh√¥ng ƒë·ªß ƒë·ªÉ t·∫°o bi·ªÉu ƒë·ªì")
                return

            # C·ªôt th·ªùi gian (c·ªôt ƒë·∫ßu ti√™n)
            x_column = df.columns[0]
            print(f"   üìÖ C·ªôt th·ªùi gian: {x_column}")

            # Chuy·ªÉn ƒë·ªïi c·ªôt th·ªùi gian
            try:
                df[x_column] = pd.to_datetime(df[x_column])
            except:
                print(f"   ‚ö†Ô∏è Kh√¥ng th·ªÉ chuy·ªÉn ƒë·ªïi c·ªôt th·ªùi gian")

            # L·ªçc c√°c c·ªôt s·ªë h·ª£p l·ªá
            numeric_columns = []
            for col in df.columns[1:]:
                if pd.api.types.is_numeric_dtype(df[col]) and df[col].count() > 0:
                    # Ki·ªÉm tra c√≥ ƒë·ªß d·ªØ li·ªáu kh√¥ng (√≠t nh·∫•t 20% kh√¥ng ph·∫£i NaN)
                    valid_ratio = df[col].count() / len(df)
                    if valid_ratio >= 0.2:
                        numeric_columns.append(col)

            print(f"   üìà T√¨m th·∫•y {len(numeric_columns)} c·ªôt d·ªØ li·ªáu h·ª£p l·ªá")

            if not numeric_columns:
                print(f"   ‚ùå Kh√¥ng c√≥ c·ªôt d·ªØ li·ªáu h·ª£p l·ªá!")
                return

            chart_count = 0

            # 1. T·∫°o bi·ªÉu ƒë·ªì ƒë∆∞·ªùng cho t·ª´ng KPI
            print(f"   üìä T·∫°o bi·ªÉu ƒë·ªì ƒë∆∞·ªùng ri√™ng l·∫ª...")
            for col_name in numeric_columns:
                try:
                    chart_path = self._create_line_chart(df, x_column, col_name, chart_folder)
                    if chart_path:
                        chart_count += 1
                except Exception as e:
                    print(f"   ‚ùå L·ªói t·∫°o bi·ªÉu ƒë·ªì ƒë∆∞·ªùng {col_name}: {e}")

            # 2. T·∫°o bi·ªÉu ƒë·ªì k·∫øt h·ª£p (ƒë∆∞·ªùng + c·ªôt)
            print(f"   üìä T·∫°o bi·ªÉu ƒë·ªì k·∫øt h·ª£p...")
            for i in range(0, len(numeric_columns) - 1, 2):
                try:
                    col1 = numeric_columns[i]
                    col2 = numeric_columns[i + 1] if i + 1 < len(numeric_columns) else None

                    if col2 and col1 != col2:
                        chart_path = self._create_combo_chart(df, x_column, col1, col2, chart_folder)
                        if chart_path:
                            chart_count += 1
                except Exception as e:
                    print(f"   ‚ùå L·ªói t·∫°o bi·ªÉu ƒë·ªì k·∫øt h·ª£p: {e}")

            print(f"   üéâ ƒê√£ t·∫°o {chart_count} bi·ªÉu ƒë·ªì cho {data_type}")

        except Exception as e:
            print(f"   ‚ùå L·ªói t·∫°o bi·ªÉu ƒë·ªì {data_type}: {e}")

    def _create_line_chart(self, df, x_col, y_col, chart_folder):
        """
        T·∫°o bi·ªÉu ƒë·ªì ƒë∆∞·ªùng cho m·ªôt KPI
        """
        try:
            plt.figure(figsize=(12, 6))

            # L·ªçc d·ªØ li·ªáu h·ª£p l·ªá
            clean_data = df[[x_col, y_col]].dropna()
            if clean_data.empty:
                plt.close()
                return None

            # V·∫Ω bi·ªÉu ƒë·ªì
            plt.plot(clean_data[x_col], clean_data[y_col],
                     marker='o', linewidth=2.5, markersize=4,
                     color='#1f77b4', alpha=0.8, label=y_col)

            # ƒê·ªãnh d·∫°ng bi·ªÉu ƒë·ªì
            plt.title(f'{y_col} Trend Analysis', fontsize=14, fontweight='bold', pad=20)
            plt.xlabel('Date/Time', fontsize=12)
            plt.ylabel(y_col, fontsize=12)
            plt.grid(True, alpha=0.3, linestyle='--')
            plt.legend(fontsize=11, loc='best')

            # ƒê·ªãnh d·∫°ng tr·ª•c x cho datetime
            if pd.api.types.is_datetime64_any_dtype(clean_data[x_col]):
                plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
                plt.gca().xaxis.set_major_locator(mdates.DayLocator(interval=max(1, len(clean_data) // 10)))

            plt.xticks(rotation=45, fontsize=10)
            plt.yticks(fontsize=10)

            # M√†u n·ªÅn
            plt.gca().set_facecolor('#f8f9fa')

            plt.tight_layout()

            # L∆∞u bi·ªÉu ƒë·ªì
            safe_filename = "".join(c for c in y_col if c.isalnum() or c in (' ', '-', '_')).replace(' ', '_')
            chart_path = os.path.join(chart_folder, f"{safe_filename}_line.png")
            plt.savefig(chart_path, dpi=300, bbox_inches='tight', facecolor='white')
            plt.close()

            return chart_path

        except Exception as e:
            plt.close()
            return None

    def _create_combo_chart(self, df, x_col, y_line, y_bar, chart_folder):
        """
        T·∫°o bi·ªÉu ƒë·ªì k·∫øt h·ª£p ƒë∆∞·ªùng v√† c·ªôt
        """
        try:
            # L·ªçc d·ªØ li·ªáu h·ª£p l·ªá
            clean_data = df[[x_col, y_line, y_bar]].dropna()
            if clean_data.empty:
                return None

            fig, ax1 = plt.subplots(figsize=(12, 6))

            # Tr·ª•c Y b√™n tr√°i (ƒë∆∞·ªùng)
            color_line = '#1f77b4'
            ax1.set_xlabel('Date/Time', fontsize=12)
            ax1.set_ylabel(y_line, color=color_line, fontsize=12, fontweight='bold')
            ax1.plot(clean_data[x_col], clean_data[y_line],
                     marker='o', color=color_line, linewidth=2.5, markersize=4,
                     label=y_line, alpha=0.8)
            ax1.tick_params(axis='y', labelcolor=color_line, labelsize=10)
            ax1.tick_params(axis='x', labelsize=10)
            ax1.grid(True, alpha=0.3, linestyle='--')

            # Tr·ª•c Y b√™n ph·∫£i (c·ªôt)
            ax2 = ax1.twinx()
            color_bar = '#ff7f0e'
            ax2.set_ylabel(y_bar, color=color_bar, fontsize=12, fontweight='bold')

            # T√≠nh ƒë·ªô r·ªông c·ªôt
            bar_width = 0.6 if len(clean_data) > 15 else 0.8

            ax2.bar(clean_data[x_col], clean_data[y_bar],
                    alpha=0.6, color=color_bar, label=y_bar, width=bar_width)
            ax2.tick_params(axis='y', labelcolor=color_bar, labelsize=10)

            # Ti√™u ƒë·ªÅ
            plt.title(f'{y_line} & {y_bar} Combined Analysis',
                      fontsize=14, fontweight='bold', pad=20)

            # ƒê·ªãnh d·∫°ng tr·ª•c x
            if pd.api.types.is_datetime64_any_dtype(clean_data[x_col]):
                fig.autofmt_xdate()
                ax1.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
            else:
                plt.xticks(rotation=45)

            # Legend k·∫øt h·ª£p
            lines1, labels1 = ax1.get_legend_handles_labels()
            lines2, labels2 = ax2.get_legend_handles_labels()
            ax1.legend(lines1 + lines2, labels1 + labels2, loc='upper left', fontsize=10)

            # M√†u n·ªÅn
            ax1.set_facecolor('#f8f9fa')

            fig.tight_layout()

            # L∆∞u bi·ªÉu ƒë·ªì
            safe_filename1 = "".join(c for c in y_line if c.isalnum() or c in (' ', '-', '_')).replace(' ', '_')
            safe_filename2 = "".join(c for c in y_bar if c.isalnum() or c in (' ', '-', '_')).replace(' ', '_')
            chart_path = os.path.join(chart_folder, f"{safe_filename1}_and_{safe_filename2}_combo.png")
            plt.savefig(chart_path, dpi=300, bbox_inches='tight', facecolor='white')
            plt.close()

            return chart_path

        except Exception as e:
            plt.close()
            return None

    def create_dashboard_report(self, output_dir="output_charts"):
        """
        T·∫°o b√°o c√°o dashboard t·ªïng h·ª£p
        """
        print(f"\nüìã T·∫°o b√°o c√°o dashboard t·ªïng h·ª£p...")

        if len(self.csv_files) < 2:
            print("   ‚ö†Ô∏è C·∫ßn √≠t nh·∫•t 2 file CSV ƒë·ªÉ t·∫°o dashboard so s√°nh")
            return None

        try:
            # T√¨m file Daily v√† Hourly
            daily_csv = None
            hourly_csv = None

            for sheet_name, csv_path in self.csv_files.items():
                if 'Daily' in sheet_name or 'daily' in sheet_name.lower():
                    daily_csv = csv_path
                elif 'Hourly' in sheet_name or 'hourly' in sheet_name.lower():
                    hourly_csv = csv_path

            if not daily_csv or not hourly_csv:
                print("   ‚ùå Kh√¥ng t√¨m th·∫•y c·∫£ file Daily v√† Hourly")
                return None

            # T·∫°o dashboard table
            dashboard_path = self._create_kpi_dashboard_table(daily_csv, hourly_csv, output_dir)

            if dashboard_path:
                # T·∫°o comprehensive report
                self._create_comprehensive_report(output_dir)

            return dashboard_path

        except Exception as e:
            print(f"   ‚ùå L·ªói t·∫°o dashboard: {e}")
            return None

    def _create_kpi_dashboard_table(self, csv_daily, csv_hourly, output_dir):
        """
        T·∫°o b·∫£ng dashboard KPI theo phong c√°ch nh∆∞ DataVisualizationFor4G_V2.py
        """
        try:
            print("üìä ƒêang t·∫°o b·∫£ng KPI Dashboard...")

            # ƒê·ªçc d·ªØ li·ªáu
            df_daily = pd.read_csv(csv_daily)
            df_hourly = pd.read_csv(csv_hourly)

            # Chuy·ªÉn ƒë·ªïi c·ªôt Date
            date_col = df_daily.columns[0]
            df_daily[date_col] = pd.to_datetime(df_daily[date_col])
            df_hourly[date_col] = pd.to_datetime(df_hourly[date_col])

            # KPI mapping cho VoLTE
            kpi_mapping = {
                # VoLTE Success Rates
                'VoLTE CSSR': ['VoLTE CSSR', 'Call Setup Success Rate', 'CSSR'],
                'VoLTE CDR': ['VoLTE CDR', 'Call Drop Rate', 'CDR'],
                'SRVCC SR': ['SRVCC SR', 'SRVCC Success Rate'],
                'VoLTE Traffic': ['VoLTE Traffic', 'Traffic', 'Call Volume'],

                # Handover Rates
                'Intra HO SR': ['Intra HO SR', 'IntraF HOSR', 'Intra Handover'],
                'Inter HO SR': ['Inter HO SR', 'InterF HOSR', 'Inter Handover'],
                'SRVCC HO SR': ['SRVCC HO SR', 'SRVCC Handover'],
                'Voice Quality': ['Voice Quality', 'MOS', 'Quality Score']
            }

            # T·∫°o figure v·ªõi 2 subplots
            fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(16, 14))
            fig.suptitle('Daily VoLTE KPI Dashboard', fontsize=18, fontweight='bold', y=0.98)

            # L·∫•y c√°c ng√†y g·∫ßn nh·∫•t
            latest = df_daily[date_col].max()
            prev = df_daily[df_daily[date_col] < latest][date_col].max() if pd.notna(latest) else pd.NaT
            week_candidate = latest - timedelta(days=7) if pd.notna(latest) else pd.NaT
            week_date = df_daily[df_daily[date_col] <= week_candidate][date_col].max() if pd.notna(
                week_candidate) else pd.NaT

            latest_dates = []
            for date in [latest, prev, week_date]:
                if pd.notna(date) and date not in latest_dates:
                    latest_dates.append(date)

            # T·∫°o dashboard cho Daily
            self._create_dashboard_subplot(ax1, df_daily, latest_dates, date_col, kpi_mapping,
                                           "Daily VoLTE KPI Dashboard (24h)", "#FF6B35")

            # T·∫°o dashboard cho Hourly
            self._create_dashboard_subplot(ax2, df_hourly, latest_dates, date_col, kpi_mapping,
                                           "Daily VoLTE KPI Dashboard (Peak Hours)", "#FFA500")

            plt.tight_layout()

            # L∆∞u dashboard
            dashboard_path = os.path.join(output_dir, "VoLTE_KPI_Dashboard.png")
            plt.savefig(dashboard_path, dpi=300, bbox_inches='tight', facecolor='white')
            plt.close()

            print(f"‚úÖ ƒê√£ t·∫°o VoLTE KPI Dashboard: {dashboard_path}")
            return dashboard_path

        except Exception as e:
            print(f"‚ùå L·ªói khi t·∫°o KPI Dashboard: {e}")
            return None

    def _create_dashboard_subplot(self, ax, df, latest_dates, date_col, kpi_mapping, title, header_color):
        """
        T·∫°o m·ªôt subplot dashboard
        """
        ax.clear()
        ax.set_xlim(0, 12)
        ax.set_ylim(0, 10)
        ax.axis('off')

        # Ti√™u ƒë·ªÅ
        ax.text(6, 9.5, title, ha='center', va='center', fontsize=14, fontweight='bold')

        # T√¨m c√°c KPI c√≥ s·∫µn trong d·ªØ li·ªáu
        available_kpis = []
        for kpi_name, possible_cols in kpi_mapping.items():
            for col_name in possible_cols:
                if col_name in df.columns:
                    available_kpis.append((kpi_name, col_name))
                    break

        if not available_kpis:
            ax.text(6, 5, 'No KPI data available', ha='center', va='center', fontsize=12)
            return

        # T·∫°o b·∫£ng v·ªõi KPI c√≥ s·∫µn (t·ªëi ƒëa 4 KPI)
        display_kpis = available_kpis[:4]
        header = ['Date'] + [kpi[0] for kpi in display_kpis]

        # Chu·∫©n b·ªã d·ªØ li·ªáu b·∫£ng
        table_data = []
        date_rows_data = []

        for date in latest_dates:
            date_str = date.strftime('%d-%b-%y')
            row_data = [date_str]

            for kpi_name, col_name in display_kpis:
                day_data = df[df[date_col].dt.date == date.date()]
                if not day_data.empty and col_name in df.columns:
                    val = day_data[col_name].iloc[0]
                    if pd.notna(val) and str(val).strip() != '':
                        try:
                            row_data.append(f"{float(val):.2f}")
                        except:
                            row_data.append('-')
                    else:
                        row_data.append('-')
                else:
                    row_data.append('-')

            table_data.append(row_data)
            date_rows_data.append(row_data)

        # Th√™m h√†ng so s√°nh n·∫øu c√≥ ƒë·ªß d·ªØ li·ªáu
        if len(date_rows_data) >= 2:
            comp_d1 = ['Compare (D-1)']
            for j in range(1, len(header)):
                try:
                    curr_str = date_rows_data[0][j]
                    prev_str = date_rows_data[1][j]

                    if curr_str != '-' and prev_str != '-':
                        curr_val = float(curr_str)
                        prev_val = float(prev_str)
                        diff = curr_val - prev_val
                        comp_d1.append(f"{diff:+.2f}")
                    else:
                        comp_d1.append('-')
                except:
                    comp_d1.append('-')
            table_data.append(comp_d1)

        # V·∫Ω b·∫£ng
        self._draw_dashboard_table(ax, header, table_data, header_color)

    def _draw_dashboard_table(self, ax, header, data, header_color):
        """
        V·∫Ω b·∫£ng dashboard
        """
        num_cols = len(header)
        num_rows = len(data) + 1  # +1 cho header

        col_width = 10 / num_cols
        row_height = 0.6

        x_start = 1
        y_start = 7

        # V·∫Ω header
        for i, col_name in enumerate(header):
            x = x_start + i * col_width
            rect = plt.Rectangle((x, y_start), col_width, row_height,
                                 facecolor=header_color, edgecolor='black', linewidth=1)
            ax.add_patch(rect)
            ax.text(x + col_width / 2, y_start + row_height / 2, col_name,
                    ha='center', va='center', fontsize=10, fontweight='bold', color='white')

        # V·∫Ω d·ªØ li·ªáu
        for row_idx, row_data in enumerate(data):
            y = y_start - (row_idx + 1) * row_height
            for col_idx, value in enumerate(row_data):
                x = x_start + col_idx * col_width

                # M√†u n·ªÅn
                if 'Compare' in str(row_data[0]):
                    bg_color = '#E6E6FA'  # Lavender cho h√†ng so s√°nh
                else:
                    bg_color = 'white'

                rect = plt.Rectangle((x, y), col_width, row_height,
                                     facecolor=bg_color, edgecolor='black', linewidth=1)
                ax.add_patch(rect)

                # M√†u ch·ªØ cho h√†ng so s√°nh
                text_color = 'black'
                font_weight = 'normal'

                if 'Compare' in str(row_data[0]) and col_idx > 0:
                    try:
                        val = float(str(value).replace('+', '').replace('-', ''))
                        if '+' in str(value):
                            text_color = 'green'
                            font_weight = 'bold'
                        elif '-' in str(value) and val > 0:
                            text_color = 'red'
                            font_weight = 'bold'
                    except:
                        pass

                font_size = 9 if len(str(value)) > 8 else 10
                ax.text(x + col_width / 2, y + row_height / 2, str(value),
                        ha='center', va='center', fontsize=font_size,
                        color=text_color, weight=font_weight)

    def _create_comprehensive_report(self, output_dir):
        """
        T·∫°o b√°o c√°o t·ªïng h·ª£p ch·ª©a dashboard v√† t·∫•t c·∫£ bi·ªÉu ƒë·ªì
        """
        try:
            print("\nüìã ƒêang t·∫°o b√°o c√°o t·ªïng h·ª£p...")

            # Thu th·∫≠p t·∫•t c·∫£ file ·∫£nh
            image_files = []

            # Dashboard
            dashboard_file = os.path.join(output_dir, "VoLTE_KPI_Dashboard.png")
            if os.path.exists(dashboard_file):
                image_files.append(dashboard_file)

            # Bi·ªÉu ƒë·ªì Daily
            daily_chart_dir = os.path.join(output_dir, "Chart_daily")
            if os.path.exists(daily_chart_dir):
                for file in os.listdir(daily_chart_dir):
                    if file.endswith('.png'):
                        image_files.append(os.path.join(daily_chart_dir, file))

            # Bi·ªÉu ƒë·ªì Hourly
            hourly_chart_dir = os.path.join(output_dir, "Chart_hourly")
            if os.path.exists(hourly_chart_dir):
                for file in os.listdir(hourly_chart_dir):
                    if file.endswith('.png'):
                        image_files.append(os.path.join(hourly_chart_dir, file))

            if not image_files:
                print("   ‚ùå Kh√¥ng t√¨m th·∫•y file ·∫£nh n√†o ƒë·ªÉ t·∫°o b√°o c√°o")
                return None

            # T·∫°o b√°o c√°o PDF/PNG t·ªïng h·ª£p
            self._create_combined_report(image_files, output_dir)

        except Exception as e:
            print(f"‚ùå L·ªói t·∫°o b√°o c√°o t·ªïng h·ª£p: {e}")

    def _create_combined_report(self, image_files, output_dir):
        """
        T·∫°o b√°o c√°o k·∫øt h·ª£p t·∫•t c·∫£ ·∫£nh
        """
        try:
            # ƒê·ªçc t·∫•t c·∫£ ·∫£nh
            images = []
            for img_path in image_files:
                try:
                    img = Image.open(img_path)
                    images.append((img, os.path.basename(img_path)))
                except Exception as e:
                    print(f"   ‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë·ªçc {img_path}: {e}")

            if not images:
                return None

            # T√≠nh to√°n layout
            dashboard_img = None
            chart_images = []

            for img, filename in images:
                if 'Dashboard' in filename:
                    dashboard_img = img
                else:
                    chart_images.append(img)

            # Layout calculation
            charts_per_row = 2
            chart_rows = math.ceil(len(chart_images) / charts_per_row)

            # K√≠ch th∆∞·ªõc
            page_width = 2100
            dashboard_height = 800 if dashboard_img else 0
            chart_width = 900
            chart_height = 600
            margin = 50
            spacing = 30
            header_height = 100

            total_height = (header_height + margin * 2 + dashboard_height +
                            spacing + chart_rows * (chart_height + spacing))

            # T·∫°o canvas
            report_img = Image.new('RGB', (page_width, total_height), 'white')
            draw = ImageDraw.Draw(report_img)

            # Header
            try:
                title_font = ImageFont.truetype("arial.ttf", 36)
                subtitle_font = ImageFont.truetype("arial.ttf", 20)
            except:
                title_font = ImageFont.load_default()
                subtitle_font = ImageFont.load_default()

            title = "VoLTE KPI COMPREHENSIVE ANALYSIS REPORT"
            title_bbox = draw.textbbox((0, 0), title, font=title_font)
            title_width = title_bbox[2] - title_bbox[0]
            draw.text(((page_width - title_width) // 2, margin), title,
                      fill='navy', font=title_font)

            subtitle = f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} | Charts: {len(chart_images)}"
            subtitle_bbox = draw.textbbox((0, 0), subtitle, font=subtitle_font)
            subtitle_width = subtitle_bbox[2] - subtitle_bbox[0]
            draw.text(((page_width - subtitle_width) // 2, margin + 50), subtitle,
                      fill='gray', font=subtitle_font)

            current_y = header_height + margin

            # Dashboard
            if dashboard_img:
                dashboard_resized = dashboard_img.resize((page_width - 2 * margin, dashboard_height),
                                                         Image.Resampling.LANCZOS)
                report_img.paste(dashboard_resized, (margin, current_y))
                current_y += dashboard_height + spacing

            # Charts
            for i, chart_img in enumerate(chart_images):
                row = i // charts_per_row
                col = i % charts_per_row

                x = margin + col * (chart_width + spacing)
                y = current_y + row * (chart_height + spacing)

                chart_resized = chart_img.resize((chart_width, chart_height),
                                                 Image.Resampling.LANCZOS)
                report_img.paste(chart_resized, (x, y))

            # L∆∞u report
            report_path = os.path.join(output_dir, "VoLTE_KPI_Comprehensive_Report.png")
            report_img.save(report_path, "PNG", quality=95)

            # L∆∞u PDF
            try:
                pdf_path = os.path.join(output_dir, "VoLTE_KPI_Comprehensive_Report.pdf")
                report_img.save(pdf_path, "PDF", quality=95)
                print(f"‚úÖ ƒê√£ t·∫°o b√°o c√°o PDF: {pdf_path}")
            except:
                print("‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫°o PDF")

            print(f"‚úÖ ƒê√£ t·∫°o b√°o c√°o t·ªïng h·ª£p: {report_path}")
            return report_path

        except Exception as e:
            print(f"‚ùå L·ªói t·∫°o b√°o c√°o k·∫øt h·ª£p: {e}")
            return None

    def process_complete_workflow(self, excel_path, output_dir="output_charts"):
        """
        Th·ª±c hi·ªán quy tr√¨nh ho√†n ch·ªânh t·ª´ Excel ƒë·∫øn b√°o c√°o
        """
        print(f"\nüéØ B·∫ÆT ƒê·∫¶U QUY TR√åNH X·ª¨ L√ù HO√ÄN CH·ªàNH")
        print(f"üìÅ File ƒë·∫ßu v√†o: {excel_path}")
        print(f"üìÅ Th∆∞ m·ª•c ƒë·∫ßu ra: {output_dir}")
        print("=" * 70)

        # B∆∞·ªõc 1: ƒê·ªçc Excel
        print("\nüìñ B∆Ø·ªöC 1: ƒê·ªåC V√Ä PH√ÇN T√çCH FILE EXCEL")
        dataframes = self.read_excel_file(excel_path)

        if not dataframes:
            print("‚ùå Kh√¥ng th·ªÉ ƒë·ªçc file Excel!")
            return False

        # B∆∞·ªõc 2: L√†m s·∫°ch d·ªØ li·ªáu
        print("\nüßπ B∆Ø·ªöC 2: L√ÄM S·∫†CH D·ªÆ LI·ªÜU")
        cleaned_dataframes = {}

        for sheet_name, df in dataframes.items():
            cleaned_df = self.clean_dataframe_enhanced(df, sheet_name)
            if cleaned_df is not None and not cleaned_df.empty:
                cleaned_dataframes[sheet_name] = cleaned_df
            else:
                print(f"‚ùå Kh√¥ng th·ªÉ l√†m s·∫°ch d·ªØ li·ªáu t·ª´ {sheet_name}")

        if not cleaned_dataframes:
            print("‚ùå Kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá sau khi l√†m s·∫°ch!")
            return False

        # B∆∞·ªõc 3: L∆∞u CSV
        print("\nüíæ B∆Ø·ªöC 3: L∆ØU D·ªÆ LI·ªÜU TH√ÄNH CSV")
        csv_files = self.save_to_csv(cleaned_dataframes, output_dir)

        if not csv_files:
            print("‚ùå Kh√¥ng th·ªÉ l∆∞u file CSV!")
            return False

        # B∆∞·ªõc 4: T·∫°o bi·ªÉu ƒë·ªì
        print("\nüé® B∆Ø·ªöC 4: T·∫†O BI·ªÇU ƒê·ªí")
        self.create_charts_from_csv(output_dir)

        # B∆∞·ªõc 5: T·∫°o dashboard v√† b√°o c√°o
        print("\nüìã B∆Ø·ªöC 5: T·∫†O DASHBOARD V√Ä B√ÅO C√ÅO T·ªîNG H·ª¢P")
        dashboard_path = self.create_dashboard_report(output_dir)

        # T·ªïng k·∫øt
        print("\n" + "=" * 70)
        print("üéâ HO√ÄN T·∫§T QUY TR√åNH X·ª¨ L√ù!")
        print("=" * 70)
        print(f"üìÅ K·∫øt qu·∫£ l∆∞u t·∫°i: {output_dir}")
        print("\nüìä C·∫•u tr√∫c k·∫øt qu·∫£:")
        print("üìÇ output_charts/")

        for sheet_name, csv_path in csv_files.items():
            print(f"   üìÑ {os.path.basename(csv_path)}")

        chart_folders = ['Chart_daily', 'Chart_hourly']
        for folder in chart_folders:
            folder_path = os.path.join(output_dir, folder)
            if os.path.exists(folder_path):
                chart_count = len([f for f in os.listdir(folder_path) if f.endswith('.png')])
                print(f"   üìÇ {folder}/ ({chart_count} bi·ªÉu ƒë·ªì)")

        if dashboard_path:
            print(f"   üìä VoLTE_KPI_Dashboard.png")

        if os.path.exists(os.path.join(output_dir, "VoLTE_KPI_Comprehensive_Report.png")):
            print(f"   üìã VoLTE_KPI_Comprehensive_Report.png")

        if os.path.exists(os.path.join(output_dir, "VoLTE_KPI_Comprehensive_Report.pdf")):
            print(f"   üìã VoLTE_KPI_Comprehensive_Report.pdf")

        print("=" * 70)
        return True


def main():
    """
    H√†m main ƒë·ªÉ ch·∫°y ch∆∞∆°ng tr√¨nh
    """
    print("üöÄ VOLTE KPI DATA PROCESSING SYSTEM")
    print("=" * 70)
    print("üìã Ch·ª©c nƒÉng:")
    print("   ‚úÖ Chuy·ªÉn ƒë·ªïi Excel sang CSV (ch·ªâ 2 sheet: Net KPI_Daily, Net KPI_Hourly)")
    print("   ‚úÖ L√†m s·∫°ch d·ªØ li·ªáu chuy√™n s√¢u")
    print("   ‚úÖ T·∫°o bi·ªÉu ƒë·ªì ƒë∆∞·ªùng v√† bi·ªÉu ƒë·ªì k·∫øt h·ª£p")
    print("   ‚úÖ T·∫°o Dashboard KPI")
    print("   ‚úÖ T·∫°o b√°o c√°o t·ªïng h·ª£p PNG/PDF")
    print("=" * 70)

    # Kh·ªüi t·∫°o processor
    processor = VoLTEKPIProcessor()

    # ƒê∆∞·ªùng d·∫´n file Excel (thay ƒë·ªïi theo file th·ª±c t·∫ø c·ªßa b·∫°n)
    excel_file = "4G_KPI Cell VoLTE_20250807.xlsx"

    # Ki·ªÉm tra file t·ªìn t·∫°i
    if not os.path.exists(excel_file):
        print(f"‚ùå Kh√¥ng t√¨m th·∫•y file: {excel_file}")
        print("üí° H√£y ƒë·∫£m b·∫£o file Excel ·ªü c√πng th∆∞ m·ª•c v·ªõi script n√†y")
        print("üí° Ho·∫∑c thay ƒë·ªïi ƒë∆∞·ªùng d·∫´n trong bi·∫øn excel_file")
        return

    # Ch·∫°y quy tr√¨nh ho√†n ch·ªânh
    success = processor.process_complete_workflow(excel_file)

    if success:
        print("\nüéä TH√ÄNH C√îNG! H√£y ki·ªÉm tra th∆∞ m·ª•c 'output_charts'")
    else:
        print("\n‚ùå C√ì L·ªñI X·∫¢Y RA! Vui l√≤ng ki·ªÉm tra l·∫°i d·ªØ li·ªáu ƒë·∫ßu v√†o")


# Utility function ƒë·ªÉ fix file CSV b·ªã l·ªói (n·∫øu c·∫ßn)
def fix_csv_file(input_csv, output_csv):
    """
    H√†m ti·ªán √≠ch ƒë·ªÉ s·ª≠a file CSV b·ªã l·ªói
    """
    processor = VoLTEKPIProcessor()

    try:
        print(f"üîß ƒêang s·ª≠a file CSV: {input_csv}")

        # ƒê·ªçc file v·ªõi header=None
        df = pd.read_csv(input_csv, header=None)

        # S·ª≠ d·ª•ng h√†m l√†m s·∫°ch c·ªßa processor
        df_cleaned = processor.clean_dataframe_enhanced(df, "CSV_Fix")

        if df_cleaned is not None:
            df_cleaned.to_csv(output_csv, index=False, encoding='utf-8-sig')
            print(f"‚úÖ ƒê√£ s·ª≠a v√† l∆∞u: {output_csv}")
            return True
        else:
            print("‚ùå Kh√¥ng th·ªÉ s·ª≠a file CSV")
            return False

    except Exception as e:
        print(f"‚ùå L·ªói khi s·ª≠a file: {e}")
        return False


if __name__ == "__main__":
    # Ki·ªÉm tra c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt
    required_packages = {
        'pandas': 'pandas',
        'matplotlib': 'matplotlib',
        'numpy': 'numpy',
        'PIL': 'Pillow',
        'openpyxl': 'openpyxl'
    }

    print("üì¶ Ki·ªÉm tra th∆∞ vi·ªán c·∫ßn thi·∫øt:")
    missing_packages = []

    for package, install_name in required_packages.items():
        try:
            __import__(package)
            print(f"   ‚úÖ {package}")
        except ImportError:
            print(f"   ‚ùå {package} - C·∫ßn c√†i ƒë·∫∑t: pip install {install_name}")
            missing_packages.append(install_name)

    if missing_packages:
        print(f"\n‚ö†Ô∏è Vui l√≤ng c√†i ƒë·∫∑t c√°c package c√≤n thi·∫øu:")
        print(f"pip install {' '.join(missing_packages)}")
        exit()

    print("\n")

    # Ch·∫°y ch∆∞∆°ng tr√¨nh ch√≠nh
    main()